<section class="design-point">
  <section class="title">
    <h2>設計ポイント</h2>

    <p>
      すべてを完璧に実装できているわけではありませんが、設計のポイントについて記載します。
    </p>
  </section>

  <section class="item-group">
    <h3>変化に適用し易くする、変更し易くする設計を優先</h3>

    <p>高凝集・低結合 になるように、全体的に意識して実装しました。</p>
  </section>

  <section class="item-group">
    <h3>基本的にWidgetとステートは分離する</h3>

    <p>
      そもそもステートが不要なWidgetは対象外ですが、ステートが必要なWidgetは、Widgetとステートを別ファイルに分離しました。
      そのため、基本的に、自分のアプリ内のWidgetは、StatefulWidgetは利用せずに、StatelessWidgetを基に作成しました。
      分離した理由は2点あります。1点目は、StatefulWidgetを利用しなくて済むかどうか、試してみたいという思いがあったためです。
      2点目は、複数箇所で使い回せる汎用的なWidgetを定義するためには、ステートを分離する必要があるのではと考えていたためです。
      分離したステートの利用する場合、コンストラクタで渡す、あるいは、riverpod経由で利用するようにしました。
      分離した結果ですが、まず、StatefulWidgetを利用しなくて済むか、という点については、自分が作成したアプリの範囲では、利用しなくて済みました。
      (StatefulWidgetを絶対に使いたくない、というわけではないため、今後、StatefulWidgetを利用した方が適切なケースがあれば利用します)
      また、ステートを分離することで、複数箇所で使い回せる汎用的なWidgetを定義することも実現できたと思っています。
    </p>
  </section>

  <section class="item-group">
    <h3>Widgetを3種類に分類して定義</h3>

    <p>下記の通り、Widgetを主に3種類に分類して定義しました。</p>

    <ul>
      <li>①「部品的なWidget」</li>
      <li>②「①を統合する用途のWidget」</li>
      <li>③「生成器的なWidget」</li>
    </ul>

    <p>
      基本的には、まず①を定義して、次に②で、①をまとめて利用します。
      本アプリでは、②をpageという単位で扱いましました。
      ①に詳細を隠蔽して、②は①の詳細を知らなくてよくなり、変更し易くなると考えました。
      また、複数箇所で同じデザインのWidgetを使い回したいケースに対応するために、
      まず③を定義して、その③を基にして、各ケースに合う①を定義し分けるようにしました。
      例えばボタンのWidgetの場合、③に渡すステートを変えることで、
      同じデザインだが、表示名やonPressedの処理が異なるボタン(①に該当)を定義するようにしました。
      もしデザイン変更したい場合、複数の①を変更する必要はなく、
      ③の定義を1箇所変更するだけで良くなり、デザイン変更しやすくなると考えました。
    </p>
  </section>

  <section class="item-group">
    <h3>アプリ内のステートを3種類に分類して定義</h3>

    <p>下記の通り、アプリ内のステートを主に3種類に分類して定義しました。</p>

    <ul>
      <li>①Widget固有のステート</li>
      <li>②アプリの各機能のコアとなるステート</li>
      <li>③アプリ外部とデータやり取りするためのステート</li>
    </ul>

    <p>
      ①は「基本的にWidgetとステートは分離する」の節で記載した、Widgetから分離したステートです。
      基本的に、特定のWidget(とそれらのWidgetをまとめるWidget)からのみ利用されるステートです。
      ①に対して、②は、特定のWidget以外からも利用されるステートです。
      各機能のdomainディレクトリ配下に定義しました。
      ③は「ディレクトリ構成」の節でいうと「channelとuser」のディレクトリです。
      主にFirestoreへのデータの出し入れに利用するステートです。
      分類した理由は、下記の通りです。
      まず、特定のWidgetのみで利用するステート(①に該当)があると考えました。
      この①と②を混在させたくないと考え、①を定義することにしました。
      次に、①以外で、アプリの機能毎にで関心があるステート(②に該当)があると考えました。
      例えば、認証機能であればサインイン済みか否か、ポインタ機能であればポインタの座標、等です。
      これらは、①と分離し、②として定義しました。
      最後に③ですが、②のステートをアプリ外部で永続化したいケースを考えました。
      このケースでは、機能毎に定義した②毎にアプリ外部とやり取りする実装を記述すると、
      外部とやり取りする実装箇所が増えると考えました。
      そのため今後、変更が必要になった場合、変更箇所が増え、変更しづらくなると考えました。
      そのため、②の中で永続化したい値のみを③に集約してきて、
      ③を基に、アプリ外部とやり取り(永続化など)することにしました。
      最終的に、①はWidgetのファイルと並ぶ形で別ファイルに定義しました。
      ②は、各機能のdomain配下に定義しました。
      ③は、機能別のディレクトリ配下に定義しました。
    </p>
  </section>

  <section class="item-group">
    <h3>Widgetの関心事を自身のステートの管理に限定する</h3>

    <p>下記の通り、Widgetの関心事を主に2つに限定しました。</p>

    <ul>
      <li>①自身のステートが変化したらUIに反映する。</li>
      <li>②自身のステートを変更する。</li>
    </ul>

    <p>
      Widgetは自身のステートを変更しても、
      そのステートの変更を永続化しているか否か、知らなくて済む状態を実現できないか、と考えました。
      より具体的には、あるWidgetでボタンを押下して、ステートを更新したとします。
      そのボタンのonPressedの処理では、ステートの更新のみを行うようにし、
      続けて、手続き的に、永続化の処理を実行しないようにしました。
      このようにWidgetの関心事を自身のステートの管理に限定することで、
      Widgetと永続化の処理を疎結合に保つことができ、
      結果、お互いの変更の影響を隔離できるのではと考えたためです。
      限定した後、永続化の処理は、riverpodの特性を利用して、別途、ステートを監視しておき、
      ステートが更新されたら、その更新をトリガーにして永続化の処理が実行されるようにしました。
    </p>
  </section>

  <section class="item-group">
    <h3>ルーティング定義の肥大化を避けるため、認証前と認証後で分離</h3>

    <p>
      当初、ルーティングのリダイレクト処理等を実装していると、ルーティングの定義が肥大化しそうな懸念がありました。
      また、ルーティングの定義を分離可能か試したい思いもありました。
      そのため、認証前と認証後で、ルーティングの定義を分離する設計にしました。
      ルーティングの定義を分割する実装ができるようになれば、例えば、認証などの機能の追加・削除を行い易くなる、
      プラグイン的な設計が実現できるのではと考えました。
      (認証機能を削除・追加する例は現実的ではないですが、他の部分でも応用できると考えています)
      実際、ルーティングを分離でき、イメージしていたプラグイン的な設計が実現できたと思っています。
      また、モノリシックなルーティング定義を扱わなくて済む点も、変更を行い易い状態になったと思っています。
    </p>
  </section>

  <section class="item-group">
    <h3>他の機能を利用する場合、詳細を隠蔽しておく</h3>

    <p>
      機能単位でTopディレクトリを分割しているのですが、他の機能を利用する場合、
      利用されるコートが記載されたファイルを、直接importしないようにしました。
      代わりに、機能単位で、機能外部に公開するファイルは、事前に明示的にexportしておくようにしました。
      そして、利用する側は、exportを記載したファイルをimportして利用するようにしました。
      利用される側から見ると、機能の外部に公開しているコードを明確にできます。
      また、利用する側から見ると、他機能に依存していることは分かるが、
      どのファイルに依存しているか等の詳細は知らなくても利用可能になります。
      各機能の境界をより明確にできて、変更の影響を把握しやすくなり、結果、変更し易くなると考えています。
      ※正当な方法としては、機能を別packageとして切り出して実現した方が良いと思われますが、そこまではまだ実現できていない状況です。
    </p>
  </section>

  <section class="item-group">
    <h3>
      アプリ全体に適用したいデザインを適用するためのレイヤを用意して、デザインの統一性を保つ
    </h3>

    <p>
      デザインの統一性を保ち易い設計にしたいという思いがありました。
      そのため、MaterialApp.routerウィジェット内のbuilder内に、
      「アプリ全体に適用したいデザインを適用するためのレイヤとなるWidget」を用意しました。
      そのため、ルーティングで画面遷移しても、常にこのレイヤが親Widgetとして存在している状態にしました。
      結果、デザインの統一性を保ちやすい設計になったと考えています。
    </p>
  </section>

  <section class="item-group">
    <h3>
      外部サービスを差し替えし易くするために、自分のアプリと外側との境界を疎結合に保つ
    </h3>

    <p>
      Repositoryパターンに相当するかと思います。
      自分のアプリの内側と外側の境界にインタフェースを定義しました。
      デバイスの機能や外部サービスなど、アプリ外とのやり取りは、このインタフェースを介して行うようにしました。
      もし、外部サービスを他社サービスに変更することになっても、自分のアプリ側の影響を最小限に限定できるように設計しました。
    </p>
  </section>
</section>

<!-- <section class="item-group">
    <h3>自分のアプリで扱いやすいWidgetを定義する</h3>

    <p>
      まず、Flutterが用意している一般的なWidgetから、自分のアプリ内で利用する「パーツ的なWidget」を、自分のアプリ内で扱いやすい粒度で定義しました。
      この「パーツ的なWidget」は、汎用的なWidgetとして、複数箇所で使い回したいケースが想定されるため、ステートは分離しました。
      そして、分離したステートは、Widgetをインスタンス化する際に、コンストラクタの引数として、渡すようにしました。
      次に「パーツ的なWidgetをまとめるためのWidget」を定義しました。
      一般的に、Page、Screen、View等と呼ばれる単位に相当するかと思っています。
      この「パーツ的なWidgetをまとめるためのWidget」でもステートは分離しました。
      ステートを分離した理由としては、複数の「パーツ的なWidget」を統合する責務のため、
      コードが肥大化する懸念があり、理解容易性の低下を避けるために、分離しようと考えたためです。
    </p>
  </section> -->

<!-- <section class="item-group">
    <h3>同デザインのWidgetを使い回しやすくする</h3>

    <p>
      例えば、サインイン用のボタンですが、ボタンの表示名やonPressedの処理は変えたいが、
      同じデザインのボタンを複数カ所で利用したい要望がありました。
      実現する案として①と②を検討しました。
    </p>

    <ul>
      <li>
        ①ボタンの表示名やonPressedの処理を変えた、同じデザインのボタンWidgetを複数作成する案
      </li>
      <li>
        ②同じデザインのボタンWidgetは1つだけ用意して、ボタンの表示名やonPressedの処理を、ボタンWidgetに渡す案
      </li>
    </ul>

    <p>
      ①の場合、各ボタン毎に変更の影響を分離できるメリットがありますが、一方、変更箇所が多くなり、変更の手間が増えるデメリットがあると考えました。
      ②の場合、①の逆のメリットがあると考えました。
      また、①は地道にやれば実装できる自信がありましたが、それに比べて、②はサンプルを動かしながら試さないとうまく実装できない印象でした。
      ①と②を比較した結果、②の方を実現できるようになった方が、今後、①と②を使い分けできるようになり、設計の幅が広がると考え、
      自身の実装力の向上のための投資と考えて、②を採用しました。
      最終的に、ボタンWidgetから、ボタンの表示名やonPressedの処理を分離し、ボタン用のステートとして定義しました。
      このボタン用のステートを用途毎に用意し、同じボタンWidgetに渡すボタン用ステートを変える設計にしました。
    </p>
  </section> -->

<!-- <section class="item-group">
    <h3>ユーザ間のデータ共有</h3>
    <p>
      基本的に、自分のアプリ内のWidgetは、自分のアプリ内のステートだけを知っている。自分のアプリ外のことは知らない。
      という考えで実装しました。
      そのため、Widgetの責務は、ステートを更新する。ステートが更新されたらUIに反映する。ことに制限して実装しました。
      一方、Widgetからステートが更新された後、例えば、Firestoreや、デバイスのshared_preferencesに永続化するための処理は次のように設計しました。
      Riverpodを利用して、ステートの更新を監視しておきます。そして、ステートが更新されたら、その更新を検知して永続化の処理が実行されるように設計・実装しました。
      このようにWidgetの責務・関心事を限定した設計にすることで、永続化の処理を、疎結合に設計しました。
    </p>
  </section> -->
