<section class="design-point">
  <section class="title">
    <h2>設計ポイント</h2>

    <p>
      すべてを完璧に実装できているわけではありませんが、設計のポイントについて記載します。
    </p>
  </section>

  <section class="item-group">
    <h3>変化に適応し易くする、変更し易くする設計を優先</h3>

    <p>高凝集・低結合 になるように、全体的に意識して実装しました。</p>
  </section>

  <div id="separateWidgetState"></div>
  <section class="item-group">
    <h3>基本的にWidgetとステートは分離する</h3>

    <p>
      そもそもステートが不要なWidgetは対象外ですが、ステートが必要なWidgetは、Widgetとステートを別ファイルに分離しました。
      そのため、基本的に、自分のアプリ内のWidgetは、StatefulWidgetは利用せずに、StatelessWidgetを基に作成しました。
    </p>

    <p>
      分離した理由は2点あります。1点目は、StatefulWidgetを利用しなくて済むかどうか、試してみたいという思いがあったためです。
      2点目は、複数箇所で使い回せる汎用的なWidgetを定義するためには、ステートを分離する必要があるのではと考えていたためです。
      分離したステートの利用する場合、コンストラクタで渡す、あるいは、riverpod経由で利用するようにしました。
    </p>

    <p>
      分離した結果ですが、自分が作成したアプリの範囲では、StatefulWidgetは利用しなくて済みました。
      (StatefulWidgetを絶対に使いたくない、というわけではないため、今後、StatefulWidgetを利用した方が適切なケースがあれば利用します)
      また、ステートを分離することで、複数箇所で使い回せる汎用的なWidgetを定義することも実現できたと思っています。
    </p>

    <!-- <p>
      分離した結果ですが、まず、StatefulWidgetを利用しなくて済むか、という点については、自分が作成したアプリの範囲では、利用しなくて済みました。
      (StatefulWidgetを絶対に使いたくない、というわけではないため、今後、StatefulWidgetを利用した方が適切なケースがあれば利用します)
      次に、複数箇所で使い回せる汎用的なWidgetを定義するためには、ステートを分離する必要があるのではと考えた点については、
      ステートを分離することで、複数箇所で使い回せる汎用的なWidgetを定義することも実現できたと思っています。
    </p> -->
  </section>

  <section class="item-group">
    <h3>Widgetを3種類に分類して定義</h3>

    <p>下記の通り、Widgetを主に3種類に分類して定義しました。</p>

    <ul>
      <li>①「部品的なWidget」</li>
      <li>②「①を統合する用途のWidget」</li>
      <li>③「生成器的なWidget」</li>
    </ul>

    <p>
      基本的には、まず①を定義して、次に②で、①をまとめて利用します。
      本アプリでは、②をpageという単位で扱いましました。
      ①に詳細を隠蔽して、②は①の詳細を知らなくて済むようにすることで、Widgetを組み換え易くなると考えました。
    </p>

    <p>
      また、複数箇所で同じデザインのWidgetを使い回したいケースに対応するために、
      まず③を定義して、その③を基にして、各ケースに合う①を定義し分けるようにしました。
      例えばボタンのWidgetの場合、③に渡すステートを変えることで、
      同じデザインだが、表示名やonPressedの処理が異なるボタン(①に該当)を定義するようにしました。
      もしデザイン変更したい場合、複数の①を変更する必要はなく、
      ③の定義を1箇所変更するだけで良くなり、デザイン変更しやすくなると考えました。
    </p>
  </section>

  <section class="item-group">
    <h3>アプリ内のステートを3種類に分類して定義</h3>

    <p>下記の通り、アプリ内のステートを主に3種類に分類して定義しました。</p>

    <ul>
      <li>①Widget固有のステート</li>
      <li>②アプリの各機能のコアとなるステート</li>
      <li>③アプリ外部とデータやり取りするためのステート</li>
    </ul>

    <p>
      ①は「<a href="#separateWidgetState">基本的にWidgetとステートは分離する</a
      >」の節で記載した、Widgetから分離したステートです。
      基本的に、特定のWidget(とそれらのWidgetをまとめるWidget)からのみ利用されるステートです。
      各機能のpresentationディレクトリ配下に定義しました。
      ①に対して、②は、特定のWidget以外からも利用されるステートです。
      各機能のdomainディレクトリ配下に定義しました。 ③は「<a
        href="#dirStructure"
        >ディレクトリ構成</a
      >」の節でいうと「channel、user」配下のdomainディレクトリ配下で定義しました。
      主にFirestoreへのデータの出し入れに利用するステートです。
    </p>

    <p>
      分類した理由は、下記の通りです。
      まず、特定のWidgetのみで利用するステート(①に該当)があると考えました。
      この①と②を混在させたくないと考え、①を定義することにしました。
    </p>

    <p>
      次に、①以外で、アプリの各機能単位で関心があるステート(②に該当)があると考えました。
      例えば、認証機能であればサインイン済みか否か、ポインタ機能であればポインタの座標、等です。
      これらは、①と分離し、②として定義しました。
    </p>

    <p>
      最後に③ですが、②のステートをアプリ外部で永続化したいケースを考えました。
      このケースでは、機能単位で定義した②毎にアプリ外部とやり取りする実装を記述すると、
      外部とやり取りする実装箇所が増えると考えました。
      そのため今後、変更が必要になった場合、変更箇所が増え、変更しづらくなると考えました。
      そのため、②の中で永続化したい値のみを③に集約してきて、
      ③を基に、アプリ外部とやり取り(永続化など)することにしました。
    </p>

    <!-- <p>
      最終的に、①のファイルはWidgetのファイルと隣接するように別ファイルで定義しました。
      ②は、各機能のdomain配下に定義しました。
      ③は、機能別のディレクトリ配下に定義しました。
    </p> -->
  </section>

  <section class="item-group">
    <h3>Widgetの関心事を自身のステートに限定し、永続化の処理を疎結合にする</h3>

    <p>下記の通り、Widgetの関心事を主に2つに限定しました。</p>

    <ul>
      <li>①自身のステートが変化したらUIに反映する。</li>
      <li>②自身のステートを変更する。</li>
    </ul>

    <section class="description-image">
      <p>
        <img
          width="700"
          src="/images/widget_limit_interest_to_self_state.png"
        />
      </p>
    </section>

    <p>
      Widgetの関心事を自身のステートのみに限定し、永続化については、知らなくて済む状態にできれば、
      「ステートの変更処理」と「永続化の処理」を疎結合にでき、変更し易い設計になると考えました。
      そのため、Wigetでは「ステートの変更処理」のみ行うように、関心事を限定しました。
      そして、「永続化の処理」は、riverpodを利用して、ステートの変化を監視しておき、
      ステートが変更されたら、その変更をトリガーにして「永続化の処理」が実行されるようにしました。
    </p>

    <!-- <p>
      例えば、あるWidgetでボタンを押下した時に、ステートを変更するとします。
      もし、この変更を永続化したい場合、そのボタンのonPressedの処理内で、
      「ステートを変更する処理」に続けて「永続化の処理」も実行すると思われます。
      この場合、Widgetは「ステートを変更する責務」と「永続化する責務」の、
      2つの責務を担うことになります。
    </p> -->

    <!-- <p>
      Widgetは自身のステートを変更しても、
      そのステートの変更を永続化しているか否か、知らなくて済む状態を実現できないか、と考えました。
      そのボタンのonPressedの処理では、「ステートを変更する処理」のみ実行し、
      手続き的に続けて、「永続化の処理」を実行しなくても済む状態を実現できないか、と考えました。
      このようにWidgetの関心事を自身のステートに限定することで、
      Widgetと永続化の処理を疎結合に保つことができ、
      結果、お互いの変更の影響を隔離できるのと考えたためです。
      限定した後、永続化の処理は、riverpodの特性を利用して、別途、ステートの変化を監視しておき、
      ステートが変更されたら、その変更をトリガーにして永続化の処理が実行されるようにしました。
    </p> -->
  </section>

  <section class="item-group">
    <h3>ルーティング定義の肥大化を避けるため、認証前と認証後で分離</h3>

    <p>
      当初、ルーティングのリダイレクト処理等を実装していると、ルーティングの定義が肥大化しそうな懸念がありました。
      また、ルーティングの定義を分離可能か試したい思いもありました。
      そのため、認証前と認証後で、ルーティングの定義を分離する設計にしました。
    </p>

    <!-- </br></br> -->

    <p>
      ルーティングの定義を分割する実装ができるようになれば、例えば、認証などの機能の追加・削除を行い易くなる、
      プラグイン的な設計が実現できるのではと考えました。
      (認証機能を削除・追加する例は現実的ではないですが、他の部分でも応用できると考えています)
      実際、ルーティングを分離でき、イメージしていたプラグイン的な設計が実現できたと思っています。
      また、モノリシックなルーティング定義を扱わなくて済む点も、変更を行い易い状態になったと思っています。
    </p>
  </section>

  <section class="item-group">
    <h3>他の機能を利用する場合、詳細を隠蔽しておく</h3>

    <p>
      機能単位でTopディレクトリを分割しているのですが、他の機能を利用する場合、
      下記の流れで利用する設計にしました。
    </p>

    <ol>
      <li>
        まず、利用される側は、利用されるコードのファイルを明示的に、exportしておきます。
      </li>
      <li>
        次に、利用する側は、そのexportされたファイルをimportして利用します。
      </li>
    </ol>

    <p>
      この設計によって、利用される側は、外部から利用される、あるいは、利用されないファイルを明確にできます。
      一方、利用する側は、他機能に依存していることは分かるが、具体的にどのファイルに依存しているか、詳細は知らなくても利用可能になります。
      結果、機能内部の詳細を、変更し易い設計になっていると考えています。
    </p>

    <!-- <p>
      機能単位でTopディレクトリを分割しているのですが、他の機能を利用する場合、
      利用されるコードが記載されたファイルを、直接importしないようにしました。
      代わりに機能単位で、機能外部に公開するファイルは、事前に明示的にexportしておくようにしました。
      そして、利用する側は、exportを記載したファイルをimportして利用するようにしました。

    </br></br>

      利用される側から見ると、機能の外部に公開しているコードを明確にできます。
      また、利用する側から見ると、他機能に依存していることは分かるが、
      具体的にどのファイルに依存しているか等の詳細は知らなくても利用可能になります。

    </br></br>

      各機能の境界をより明確にできて、変更の影響を把握しやすくなり、結果、変更し易くなると考えています。
    </br>
      ※正当な方法としては、機能を別packageとして切り出して実現した方が良いと思われますが、そこまではまだ実現できていない状況です。
    </p> -->
  </section>

  <section class="item-group">
    <h3>
      デザインの統一性を保つために、アプリ全体にデザインを適用するためのレイヤを用意
    </h3>

    <p>
      デザインの統一性を保ち易い設計にしたいという思いがありました。
      そのため、MaterialApp.routerウィジェット内のbuilder内に、
      「アプリ全体にデザインを適用するためのレイヤ」となるWidgetを用意しました。
      そのため、ルーティングで画面遷移しても、常にこのレイヤが親Widgetとして存在している状態にしました。
      結果、デザインの統一性を保ちやすい設計になっていると考えています。
    </p>
  </section>

  <section class="item-group">
    <h3>
      外部サービスを差し替えし易くするために、自分のアプリと外側との境界を疎結合に保つ
    </h3>

    <p>
      Repositoryパターンに相当するかと思います。
      自分のアプリの内側と外側の境界にインタフェースを定義しました。
      デバイスの機能や外部サービスなど、アプリ外とのやり取りは、このインタフェースを介して行うようにしました。
      もし、外部サービスを他社サービスに変更することになっても、自分のアプリ側の影響を最小限に限定できるように設計しました。
    </p>
  </section>
</section>
